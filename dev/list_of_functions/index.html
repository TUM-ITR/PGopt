<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>List of fuctions ·  </title><meta name="title" content="List of fuctions ·  "/><meta property="og:title" content="List of fuctions ·  "/><meta property="twitter:title" content="List of fuctions ·  "/><meta name="description" content="Documentation for  ."/><meta property="og:description" content="Documentation for  ."/><meta property="twitter:description" content="Documentation for  ."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="  logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../"> </a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../examples/autocorrelation/">Autocorrelation</a></li><li><a class="tocitem" href="../examples/PG_OCP_known_basis_functions/">Optimal control with known basis functions</a></li><li><a class="tocitem" href="../examples/PG_OCP_generic_basis_functions/">Optimal control with generic basis functions</a></li></ul></li><li class="is-active"><a class="tocitem" href>List of fuctions</a></li><li><a class="tocitem" href="../reference/">Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>List of fuctions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>List of fuctions</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/TUM-ITR/PGopt" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/TUM-ITR/PGopt/blob/main/Julia/docs/src/list_of_functions.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="List-of-fuctions"><a class="docs-heading-anchor" href="#List-of-fuctions">List of fuctions</a><a id="List-of-fuctions-1"></a><a class="docs-heading-anchor-permalink" href="#List-of-fuctions" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PGopt.particle_Gibbs-Tuple{Any, Any, Any, Any, Any, Any, Function, Vararg{Any, 8}}" href="#PGopt.particle_Gibbs-Tuple{Any, Any, Any, Any, Any, Any, Function, Vararg{Any, 8}}"><code>PGopt.particle_Gibbs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">particle_Gibbs(u_training, y_training, K, K_b, k_d, N, phi::Function, Lambda_Q, ell_Q, Q_init, V, A_init, x_init_dist, g, R; x_prim=nothing)</code></pre><p>Run particle Gibbs sampler with ancestor sampling to obtain samples <span>$\{A, Q, x_{T:-1}\}^{[1:K]}$</span> from the joint parameter and state posterior distribution <span>$p(A, Q, x_{T:-1} \mid \mathbb{D}=\{u_{T:-1}, y_{T:-1}\})$</span>.</p><p><strong>Arguments</strong></p><ul><li><code>u_training</code>: training input trajectory</li><li><code>y_training</code>: training output trajectory</li><li><code>K</code>: number of models/scenarios to be sampled</li><li><code>K_b</code>: length of the burn in period</li><li><code>k_d</code>: number of models/scenarios to be skipped to decrease correlation (thinning)</li><li><code>N</code>: number of particles</li><li><code>phi</code>: basis functions</li><li><code>Lambda_Q</code>: scale matrix of IW prior on <span>$Q$</span></li><li><code>ell_Q</code>: degrees of freedom of IW prior on <span>$Q$</span></li><li><code>Q_init</code>: initial value of <span>$Q$</span></li><li><code>V</code>: left covariance matrix of MN prior on <span>$A$</span></li><li><code>A_init</code>: initial value of <span>$A$</span></li><li><code>x_init_dist</code>: distribution of the initial state</li><li><code>g</code>: observation function</li><li><code>R</code>: variance of zero-mean Gaussian measurement noise</li><li><code>x_prim</code>: prespecified trajectory for the first iteration</li></ul><p>This function is based on the papers</p><pre><code class="nohighlight hljs">A. Svensson and T. B. Schön, “A flexible state–space model for learning nonlinear dynamical systems,” Automatica, vol. 80, pp. 189–199, 2017.

F. Lindsten, T. B. Schön, and M. Jordan, “Ancestor sampling for particle Gibbs,” Advances in Neural Information Processing Systems, vol. 25, 2012.</code></pre><p>and the code provided in the supplementary material.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TUM-ITR/PGopt/blob/e871b3c12f88433074fcd55b24a2cfdcf4dee55b/Julia/src/particle_Gibbs.jl#L82-L112">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PGopt.solve_PG_OCP-Tuple{Vector{PG_sample}, Function, Vararg{Any, 7}}" href="#PGopt.solve_PG_OCP-Tuple{Vector{PG_sample}, Function, Vararg{Any, 7}}"><code>PGopt.solve_PG_OCP</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">solve_PG_OCP(PG_samples::Vector{PG_sample}, phi::Function, R, H, u_min, u_max, y_min, y_max, R_cost_diag; x_vec_0=nothing, v_vec=nothing, e_vec=nothing, u_init=nothing, K_pre_solve=0, active_constraints=nothing, opts=nothing, print_progress=true)</code></pre><p>Solve the optimal control problem of the following form:</p><p><span>$\min \sum_{t=0}^{H} \frac{1}{2}  u_t  \operatorname{diag}(R_{\mathrm{cost}}) u_t$</span></p><p>subject to:</p><p class="math-container">\[\begin{aligned}
\forall k, \forall t \\
x_{t+1}^{[k]} &amp;= f_{\theta^{[k]}}(x_t^{[k]}, u_t) + v_t^{[k]} \\
x_{t, 1:n_y}^{[k]} &amp;\geq y_{\mathrm{min},\ t} - e_t^{[k]} \\
x_{t, 1:n_y}^{[k]} &amp;\leq y_{\mathrm{max},\ t} - e_t^{[k]} \\
u_t &amp;\geq u_{\mathrm{min},\ t} \\
u_t &amp;\leq u_{\mathrm{max},\ t}.
\end{aligned}\]</p><p>Note that the output constraints imply the measurement function <span>$y_t^{[k]} = x_{t, 1:n_y}^{[k]}$</span>. Further note that the states of the individual models (<span>$x^{[1:K]}$</span>) are combined in the vector <code>x_vec</code> of dimension K * n_x.</p><p><strong>Arguments</strong></p><ul><li><code>PG_samples</code>: PG samples</li><li><code>phi</code>: basis functions</li><li><code>R</code>: variance of zero-mean Gaussian measurement noise - only used if <code>e_vec</code> is not passed</li><li><code>H</code>: horizon of the OCP</li><li><code>u_min</code>: array of dimension 1 x 1 or 1 x H containing the minimum control input for all timesteps</li><li><code>u_max</code>: array of dimension 1 x 1 or 1 x H containing the maximum control input for all timesteps</li><li><code>y_min</code>: array of dimension 1 x 1 or 1 x H containing the minimum system output for all timesteps</li><li><code>y_max</code>: array of dimension 1 x 1 or 1 x H containing the maximum system output for all timesteps</li><li><code>R_cost_diag</code>: parameter of the diagonal quadratic cost function</li><li><code>x_vec_0</code>: vector with <span>$K n_x$</span> elements containing the initial state of all models - if not provided, the initial states are sampled based on the PGS samples</li><li><code>v_vec</code>: array of dimension n_x x H x K that contains the process noise for all models and all timesteps - if not provided, the noise is sampled based on the PGS samples</li><li><code>e_vec</code>: array of dimension n_y x H x K that contains the measurement noise for all models and all timesteps - if not provided, the noise is sampled based on the provided <code>R</code></li><li><code>u_init</code>: initial guess for the optimal trajectory</li><li><code>K_pre_solve</code>: if <code>K_pre_solve</code> &gt; 0, an initial guess for the optimal trajectory is obtained by solving the OCP with only <code>K_pre_solve</code> &lt; <code>K</code> models</li><li><code>active_constraints</code>: vector containing the indices of the models, for which the output constraints are active - if not provided, the output constraints are considered for all models</li><li><code>opts</code>: SolverOptions struct containing options of the solver</li><li><code>print_progress</code>: if set to true, the progress is printed</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TUM-ITR/PGopt/blob/e871b3c12f88433074fcd55b24a2cfdcf4dee55b/Julia/src/optimal_control_Altro.jl#L61-L101">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PGopt.solve_PG_OCP_greedy_guarantees-Tuple{Vector{PG_sample}, Function, Vararg{Any, 8}}" href="#PGopt.solve_PG_OCP_greedy_guarantees-Tuple{Vector{PG_sample}, Function, Vararg{Any, 8}}"><code>PGopt.solve_PG_OCP_greedy_guarantees</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">solve_PG_OCP_greedy_guarantees(PG_samples::Vector{PG_sample}, phi::Function, R, H, u_min, u_max, y_min, y_max, R_cost_diag, β; x_vec_0=nothing, v_vec=nothing, e_vec=nothing, u_init=nothing, K_pre_solve=0, opts=nothing, print_progress=true)</code></pre><p>Solve the following optimal control problem and determine a support sub-sample with cardinality <span>$s$</span> via a greedy constraint removal.  Based on the cardinality <span>$s$</span>, a bound on the probability that the incurred cost exceeds the worst-case cost or that the constraints are violated when the input trajectory <span>$u_{0:H}$</span> is applied to the unknown system is calculated (i.e., <span>$1-\epsilon$</span> is determined).</p><p><span>$\min \sum_{t=0}^{H} \frac{1}{2}  u_t  \operatorname{diag}(R_{\mathrm{cost}}) u_t$</span></p><p>subject to:</p><p class="math-container">\[\begin{aligned}
\forall k, \forall t \\
x_{t+1}^{[k]} &amp;= f_{\theta^{[k]}}(x_t^{[k]}, u_t) + v_t^{[k]} \\
x_{t, 1:n_y}^{[k]} &amp;\geq y_{\mathrm{min},\ t} - e_t^{[k]} \\
x_{t, 1:n_y}^{[k]} &amp;\leq y_{\mathrm{max},\ t} - e_t^{[k]} \\
u_t &amp;\geq u_{\mathrm{min},\ t} \\
u_t &amp;\leq u_{\mathrm{max},\ t}.
\end{aligned}\]</p><p>Note that the output constraints imply the measurement function <span>$y_t^{[k]} = x_{t, 1:n_y}^{[k]}$</span>. Further note that the states of the individual models (<span>$x^{[1:K]}$</span>) are combined in the vector <code>x_vec</code> of dimension K * n_x.</p><p><strong>Arguments</strong></p><ul><li><code>PG_samples</code>: PG samples</li><li><code>phi</code>: basis functions</li><li><code>R</code>: variance of zero-mean Gaussian measurement noise - only used if <code>e_vec</code> is not passed</li><li><code>H</code>: horizon of the OCP</li><li><code>u_min</code>: array of dimension 1 x 1 or 1 x H containing the minimum control input for all timesteps</li><li><code>u_max</code>: array of dimension 1 x 1 or 1 x H containing the maximum control input for all timesteps</li><li><code>y_min</code>: array of dimension 1 x 1 or 1 x H containing the minimum system output for all timesteps</li><li><code>y_max</code>: array of dimension 1 x 1 or 1 x H containing the maximum system output for all timesteps</li><li><code>R_cost_diag</code>: parameter of the diagonal quadratic cost function</li><li><code>β</code>: confidence parameter</li><li><code>x_vec_0</code>: vector with K*n_x elements containing the initial state of all models - if not provided, the initial states are sampled based on the PGS samples</li><li><code>v_vec</code>: array of dimension n_x x H x K that contains the process noise for all models and all timesteps - if not provided, the noise is sampled based on the PGS samples</li><li><code>e_vec</code>: array of dimension n_y x H x K that contains the measurement noise for all models and all timesteps - if not provided, the noise is sampled based on the provided <code>R</code></li><li><code>u_init</code>: initial guess for the optimal trajectory</li><li><code>K_pre_solve</code>: if <code>K_pre_solve</code> &gt; 0, an initial guess for the optimal trajectory is obtained by solving the OCP with only <code>K_pre_solve</code> &lt; <code>K</code> models</li><li><code>opts</code>: SolverOptions struct containing options of the solver</li><li><code>print_progress</code>: if set to true, the progress is printed</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TUM-ITR/PGopt/blob/e871b3c12f88433074fcd55b24a2cfdcf4dee55b/Julia/src/optimal_control_Altro.jl#L361-L402">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PGopt.test_prediction-Tuple{Vector{PG_sample}, Function, Vararg{Any, 5}}" href="#PGopt.test_prediction-Tuple{Vector{PG_sample}, Function, Vararg{Any, 5}}"><code>PGopt.test_prediction</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">test_prediction(PG_samples::Vector{PG_sample}, phi::Function, g, R, k_n, u_test, y_test)</code></pre><p>Simulate the PGS samples forward in time and compare the predictions to the test data.</p><p><strong>Arguments</strong></p><ul><li><code>PG_samples</code>: PG samples</li><li><code>phi</code>: basis functions</li><li><code>g</code>: observation function</li><li><code>R</code>: variance of zero-mean Gaussian measurement noise</li><li><code>k_n</code>: each model is simulated <span>$k_n$</span> times</li><li><code>u_test</code>: test input</li><li><code>y_test</code>: test output</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TUM-ITR/PGopt/blob/e871b3c12f88433074fcd55b24a2cfdcf4dee55b/Julia/src/particle_Gibbs.jl#L238-L251">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PGopt.plot_predictions-Tuple{Any, Any}" href="#PGopt.plot_predictions-Tuple{Any, Any}"><code>PGopt.plot_predictions</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plot_predictions(y_pred, y_test; plot_percentiles=false, y_min=nothing, y_max=nothing)</code></pre><p>Plot the predictions and the test data.</p><p><strong>Arguments</strong></p><ul><li><code>y_pred</code>: matrix containing the output predictions</li><li><code>y_test</code>: test output trajectory</li><li><code>plot_percentiles</code>: if set to true, percentiles are plotted</li><li><code>y_min</code>: min output to be plotted as constraint</li><li><code>y_max</code>: max output to be plotted as constraint</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TUM-ITR/PGopt/blob/e871b3c12f88433074fcd55b24a2cfdcf4dee55b/Julia/src/particle_Gibbs.jl#L315-L326">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PGopt.plot_autocorrelation-Tuple{Vector{PG_sample}}" href="#PGopt.plot_autocorrelation-Tuple{Vector{PG_sample}}"><code>PGopt.plot_autocorrelation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plot_autocorrelation(PG_samples::Vector{PG_sample}; max_lag=0)</code></pre><p>Plot the autocorrelation function (ACF) of the PG samples. This might be helpful when adjusting the thinning parameter <span>$k_d$</span>.</p><p><strong>Arguments</strong></p><ul><li><code>PG_samples</code>: PG samples</li><li><code>max_lag</code>: maximum lag at which to calculate the ACF</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TUM-ITR/PGopt/blob/e871b3c12f88433074fcd55b24a2cfdcf4dee55b/Julia/src/particle_Gibbs.jl#L381-L389">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PGopt.epsilon-Tuple{Int64, Int64, Float64}" href="#PGopt.epsilon-Tuple{Int64, Int64, Float64}"><code>PGopt.epsilon</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">epsilon(s::Int64, K::Int64, β::Float64)</code></pre><p>Determine the parameter <span>$\epsilon$</span>. <span>$1-\epsilon$</span> corresponds to a bound on the probability that the incurred cost exceeds the worst-case cost or that the constraints are violated when the input trajectory <span>$u_{0:H}$</span> is applied to the unknown system. <span>$\epsilon$</span> is the unique solution over the interval <span>$(0,1)$</span> of the polynomial equation in the <span>$v$</span> variable:</p><p><span>$\binom{K}{s}(1-v)^{K-s}-\frac{\beta}{K}\sum_{m=s}^{K-1}\binom{m}{s}(1-v)^{m-s}=0$</span>.</p><p><strong>Arguments</strong></p><ul><li><code>s</code>: cardinality of the support sub-sample </li><li><code>K</code>: number of scenarios</li><li><code>β</code>: confidence parameter</li></ul><p>This function is based on the paper</p><pre><code class="nohighlight hljs">S. Garatti and M. C. Campi, “Risk and complexity in scenario optimization,” Mathematical Programming, vol. 191, no. 1, pp. 243–279, 2022.</code></pre><p>and the code provided in the appendix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TUM-ITR/PGopt/blob/e871b3c12f88433074fcd55b24a2cfdcf4dee55b/Julia/src/optimal_control_Altro.jl#L313-L331">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PGopt.MNIW_sample-NTuple{7, Any}" href="#PGopt.MNIW_sample-NTuple{7, Any}"><code>PGopt.MNIW_sample</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">MNIW_sample(Phi, Psi, Sigma, V, Lambda_Q, ell_Q, T)</code></pre><p>Sample new model parameters <span>$\{A, Q\}$</span> from the conditional distribution <span>$p(A, Q | x_{T:-1})$</span>, which is a matrix normal inverse Wishart (MNIW) distribution.</p><p><strong>Arguments</strong></p><ul><li><code>Phi</code>: statistic; see paper below for definition</li><li><code>Psi</code>: statistic; see paper below for definition</li><li><code>Sigma</code>: statistic; see paper below for definition</li><li><code>V</code>: left covariance matrix of MN prior on <span>$A$</span></li><li><code>Lambda_Q</code>: scale matrix of IW prior on <span>$Q$</span></li><li><code>ell_Q</code>: degrees of freedom of IW prior on <span>$Q$</span></li><li><code>T</code>: length of the training trajectory</li></ul><p>This function is based on the paper</p><pre><code class="nohighlight hljs">A. Svensson and T. B. Schön, “A flexible state–space model for learning nonlinear dynamical systems,” Automatica, vol. 80, pp. 189–199, 2017.</code></pre><p>and the code provided in the supplementary material.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TUM-ITR/PGopt/blob/e871b3c12f88433074fcd55b24a2cfdcf4dee55b/Julia/src/particle_Gibbs.jl#L35-L54">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PGopt.systematic_resampling-Tuple{Any, Any}" href="#PGopt.systematic_resampling-Tuple{Any, Any}"><code>PGopt.systematic_resampling</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">systematic_resampling(W, N)</code></pre><p>Sample <code>N</code> indices according to the weights <code>W</code>.</p><p><strong>Arguments</strong></p><ul><li><code>W</code>: vector containing the weights of the particles</li><li><code>N</code>: number of indices to be sampled</li></ul><p>This function is based on the paper</p><pre><code class="nohighlight hljs">A. Svensson and T. B. Schön, “A flexible state–space model for learning nonlinear dynamical systems,” Automatica, vol. 80, pp. 189–199, 2017.</code></pre><p>and the code provided in the supplementary material.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TUM-ITR/PGopt/blob/e871b3c12f88433074fcd55b24a2cfdcf4dee55b/Julia/src/particle_Gibbs.jl#L1-L15">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../examples/PG_OCP_generic_basis_functions/">« Optimal control with generic basis functions</a><a class="docs-footer-nextpage" href="../reference/">Reference »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.1 on <span class="colophon-date" title="Friday 17 May 2024 15:07">Friday 17 May 2024</span>. Using Julia version 1.10.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
